/// <reference types="node" />
import { Client, Collection, Guild, Message, NewsChannel, Snowflake, TextChannel, ThreadChannel } from 'discord.js';
import { EventEmitter } from 'events';
export interface Events {
    fetch: [size: number, messages: Collection<Snowflake, Message>];
    fetchChannel: [channel: FetchChannel];
    fetchGuild: [guild: Guild];
    fetchThread: [thread: ThreadChannel, parentChannel: FetchChannel | null];
}
/**
 * A fetchable TextChannel.
 */
export declare type FetchChannel = NewsChannel | TextChannel;
/**
 * The main class used to fetch things.
 */
export declare class Fetcher extends EventEmitter {
    readonly client: Client;
    /**
     * A simple property set to `true` when the Fetcher is fetching a bulk of messages, then set to false.
     */
    fetching: boolean;
    /**
     * Creates a new Fetcher.
     *
     * @param client - Needs the client to fetch things.
     */
    constructor(client: Client);
    on<K extends keyof Events>(event: K, listener: (...args: Events[K]) => void): this;
    once<K extends keyof Events>(event: K, listener: (...args: Events[K]) => void): this;
    emit<K extends keyof Events>(event: K, ...args: Events[K]): boolean;
    eventNames(): (keyof Events)[];
    off<K extends keyof Events>(event: K, listener: (...args: Events[K]) => void): this;
    /**
     * Fetch the entire list of messages from a channel, can be long and makes you have rateLimits.
     *
     * @param channelID - The channel, can be an ID or a Channel.
     * @param threads - If set to `true` it will fetch its threads, for now it will only fetch the active threads.
     * @returns - The messages fetched.
     */
    fetchChannel(channelID: Snowflake | FetchChannel, threads?: boolean): Promise<Collection<string, Message>>;
    /**
     * Fetch an array of Snowflakes or TextChannels or a collection of TextChannels.
     *
     * @param channels - The channels to fetch.
     * @param threads - If set to `true` it will fetch all the threads of all the channels, for now it will only fetch the active threads.
     * @returns - The messages fetched.
     */
    fetchChannels(channels: Array<Snowflake | FetchChannel> | Collection<Snowflake, FetchChannel>, threads?: boolean): Promise<Collection<string, Message>>;
    /**
     * Fetch an entire guild, fetching every TextChannels one by one because there is no other way.
     *
     * @remarks
     * Can be really long and you should prefer using events than waiting for it to finish.
     *
     * @param guildID - The guild to fetch, can be an ID or a Guild.
     * @param threads - If set to `true` it will fetch all the threads of the guild, for now it will only fetch the active threads.
     * @returns - The messages fetched.
     */
    fetchGuild(guildID: Snowflake | Guild, threads?: boolean): Promise<Collection<string, Message>>;
    fetchGuilds(threads?: boolean): Promise<Collection<Snowflake, Message>>;
    fetchGuilds(guilds: Collection<Snowflake, Guild> | Array<Guild>, threads: boolean): Promise<Collection<Snowflake, Message>>;
    fetchThread(thread: ThreadChannel): Promise<Collection<Snowflake, Message>>;
    fetchThread(threadID: Snowflake, channelID: Snowflake | FetchChannel): Promise<Collection<Snowflake, Message>>;
    fetchThreads(channel: Guild): Promise<Collection<Snowflake, Message>>;
    fetchThreads(channel: FetchChannel): Promise<Collection<Snowflake, Message>>;
    fetchThreads(threadsIDs: Array<ThreadChannel> | Collection<Snowflake, ThreadChannel>): Promise<Collection<Snowflake, Message>>;
    fetchThreads(threadsIDs: Array<Snowflake> | Collection<Snowflake, Snowflake>, channelID: Snowflake | FetchChannel): Promise<Collection<Snowflake, Message>>;
}
