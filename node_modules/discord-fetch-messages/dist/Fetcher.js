"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Fetcher = void 0;
const discord_js_1 = require("discord.js");
const events_1 = require("events");
function isFetchChannel(channel) {
    return channel instanceof discord_js_1.TextChannel || channel instanceof discord_js_1.NewsChannel;
}
/**
 * The main class used to fetch things.
 */
class Fetcher extends events_1.EventEmitter {
    client;
    /**
     * A simple property set to `true` when the Fetcher is fetching a bulk of messages, then set to false.
     */
    fetching;
    /**
     * Creates a new Fetcher.
     *
     * @param client - Needs the client to fetch things.
     */
    constructor(client) {
        super();
        this.client = client;
        this.fetching = false;
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    once(event, listener) {
        return super.on(event, listener);
    }
    emit(event, ...args) {
        return super.emit(event, args);
    }
    eventNames() {
        return super.eventNames();
    }
    off(event, listener) {
        return super.off(event, listener);
    }
    /**
     * Fetch the entire list of messages from a channel, can be long and makes you have rateLimits.
     *
     * @param channelID - The channel, can be an ID or a Channel.
     * @param threads - If set to `true` it will fetch its threads, for now it will only fetch the active threads.
     * @returns - The messages fetched.
     */
    async fetchChannel(channelID, threads = false) {
        const channel = typeof channelID === 'string' ? await this.client.channels.fetch(channelID) : channelID;
        let messages = new discord_js_1.Collection();
        if (isFetchChannel(channel)) {
            this.emit('fetchChannel', channel);
            this.fetching = true;
            let channelMessages = await channel.messages.fetch({ limit: 100 });
            this.emit('fetch', channelMessages.size, channelMessages);
            while (channelMessages.size > 0) {
                messages = messages.concat(channelMessages);
                channelMessages = await channel.messages.fetch({
                    limit: 100,
                    before: channelMessages.last().id,
                });
                this.emit('fetch', channelMessages.size, channelMessages);
            }
            if (threads) {
                const threadsMessages = await this.fetchThreads(channel);
                messages = messages.concat(threadsMessages);
            }
            this.fetching = false;
        }
        return messages;
    }
    /**
     * Fetch an array of Snowflakes or TextChannels or a collection of TextChannels.
     *
     * @param channels - The channels to fetch.
     * @param threads - If set to `true` it will fetch all the threads of all the channels, for now it will only fetch the active threads.
     * @returns - The messages fetched.
     */
    async fetchChannels(channels, threads = false) {
        if (channels instanceof discord_js_1.Collection)
            channels = [...channels.values()];
        let messages = new discord_js_1.Collection();
        this.fetching = true;
        for (const channel of channels) {
            const channelMessages = await this.fetchChannel(channel, threads);
            messages = messages.concat(channelMessages);
        }
        this.fetching = false;
        return messages;
    }
    /**
     * Fetch an entire guild, fetching every TextChannels one by one because there is no other way.
     *
     * @remarks
     * Can be really long and you should prefer using events than waiting for it to finish.
     *
     * @param guildID - The guild to fetch, can be an ID or a Guild.
     * @param threads - If set to `true` it will fetch all the threads of the guild, for now it will only fetch the active threads.
     * @returns - The messages fetched.
     */
    async fetchGuild(guildID, threads = false) {
        const guild = guildID instanceof discord_js_1.Guild ? guildID : await this.client.guilds.fetch(guildID);
        let messages = new discord_js_1.Collection();
        if (guild) {
            const channels = guild.channels.cache.filter(c => c.isText() && !c.isThread());
            this.emit('fetchGuild', guild);
            messages = await this.fetchChannels(channels, threads);
        }
        return messages;
    }
    /**
     * Fetch all the guilds provided, if not all the guilds in the cache of the {@link client}.
     *
     * @remarks
     * Can be really long and you should prefer using events than waiting for it to finish.
     *
     * @param guilds - The guilds to fetch, if omitted it will fetch all the guilds cached by the client.
     * @param threads - If set to `true` it will fetch all the threads of the guilds, for now it will only fetch the active threads.
     * @returns - The messages fetched.
     */
    async fetchGuilds(guilds, threads = false) {
        const guildList = guilds instanceof discord_js_1.Collection ? [...guilds.values()] : guilds instanceof Array ? guilds : [...this.client.guilds.cache.values()];
        const fetchThreads = typeof guilds === 'boolean' ? guilds : threads ?? false;
        let messages = new discord_js_1.Collection();
        for (const guild of guildList) {
            const guildMessages = await this.fetchGuild(guild, fetchThreads);
            messages = messages.concat(guildMessages);
        }
        return messages;
    }
    /**
     * Fetch the entire list of messages from a Thread.
     *
     * @remarks
     * If the thread is private, the client need the `MANAGE_THREADS` permissions.
     *
     * @param threadID - The thread ID or Thread itself, if an ID is provided you have to set the second paramter.
     * @param channelID - The channel ID or Channel itself of the Thread, only necessary if you provide a Thread ID, else it is not used.
     * @returns The messages fetched.
     */
    async fetchThread(threadID, channelID) {
        let messages = new discord_js_1.Collection();
        if (typeof threadID === 'string' && !channelID)
            throw Error('channelID is required when using ThreadID.');
        let thread = null;
        if (threadID instanceof discord_js_1.ThreadChannel)
            thread = threadID;
        else if (channelID) {
            const channel = typeof channelID === 'string' ? await this.client.channels.fetch(channelID) : channelID;
            if (isFetchChannel(channel))
                thread = await channel.threads.fetch(threadID);
            else
                return messages;
        }
        if (thread) {
            if (thread.type === 'GUILD_PRIVATE_THREAD' && !thread.permissionsFor(this.client.user)?.has(discord_js_1.Permissions.FLAGS.MANAGE_THREADS, false)) {
                return messages;
            }
            this.fetching = true;
            this.emit('fetchThread', thread, thread.parent);
            let threadMessages = await thread.messages.fetch({ limit: 100 });
            this.emit('fetch', threadMessages.size, threadMessages);
            while (threadMessages.size > 0) {
                messages = messages.concat(threadMessages);
                threadMessages = await thread.messages.fetch({
                    limit: 100,
                    before: threadMessages.last().id,
                });
                this.emit('fetch', threadMessages.size, threadMessages);
            }
            this.fetching = false;
        }
        return messages;
    }
    /**
     * Fetch the entire list of messages from multiple threads or all the threads of a channel or all threads of a guild.
     * For now it will only fetch the active threads.
     *
     * @remarks
     * If one of the thread is private, it will need the `MANAGE_THREADS` permission to be able to fetch its messages.
     * Can be really long and you should prefer using events than waiting for it to finish.
     *
     * @param threadsIDs - A list or a collection of threads or snowflakes to fetch messages from, if snowflakes are provided, you will need the second argument, or a channel where it will fetch all its channels, or a guild where it will fetch all its threads from all its channels.
     * @param channelID - The channel ID or the Channel itself parent to all the threads passed as snowflakes, it will fetch the threads from this channel.
     * @returns - All the messages fetched.
     */
    async fetchThreads(threadsIDs, channelID) {
        let messages = new discord_js_1.Collection();
        let threads = [];
        let channel = null;
        if (channelID) {
            const c = typeof channelID === 'string' ? await this.client.channels.fetch(channelID) : channelID;
            if (isFetchChannel(c))
                channel = c;
        }
        async function resolveThread(thread) {
            if (thread instanceof discord_js_1.ThreadChannel) {
                threads.push(thread);
            }
            else {
                if (channel) {
                    const t = await channel.threads.fetch(thread);
                    if (t)
                        threads.push(t);
                }
            }
        }
        if (threadsIDs instanceof discord_js_1.Guild) {
            threads = (await Promise.all((await threadsIDs.channels.fetch()).filter(isFetchChannel).map(async (c) => [...(await c.threads.fetch()).threads.values()]))).flat();
        }
        else if (isFetchChannel(threadsIDs))
            threads = [...(await threadsIDs.threads.fetch()).threads.values()];
        else if (threadsIDs instanceof discord_js_1.Collection)
            [...threadsIDs.values()].forEach(resolveThread);
        else
            threadsIDs.forEach(resolveThread);
        for (const thread of threads) {
            const threadMessages = await this.fetchThread(thread);
            messages = messages.concat(threadMessages);
        }
        return messages;
    }
}
exports.Fetcher = Fetcher;
